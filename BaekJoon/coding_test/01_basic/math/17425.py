# 코딩 테스트 준비 - 기초
# 백준 17425 약수의 합
# 등급 골드 5

# 문제
# 두 자연수 A, B가 있을 때, A = BC를 만족하는 자연수 C를 A의 약수라고 한다.
# 자연수 A의 약수의 합은 모든 약수를 더한 값이고, f(A)로 표현한다.
# x 보다 작거나 같은 모든 자연수 y의 f(y)값을 더한 값은 g(x)로 표현한다.

# 첫째 줄에 자연수 N 이 주어질 때 g(N)을 출력하라

# 문제 해결 아이디어
# 기존에 풀었던 약수의 합 알고리즘으로 해결하면 바로 시간 초과가 발생한다.
# 이를 해결하기 위해서 배수의 원리를 이용한다.
#
# 1. N = AB 일 때
# 2. A, B는 N의 약수이다.
# 3. N은 A, B의 배수이다.
# 이 아이디어를 사용하여 약수가 아닌 수는 연산하지 않으면 된다.
#
# N은 N의 약수의 배수로 이루어져있기 때문에 이를 이용하여 DP 리스트를 만들 수 있다.
# 미리 DP 배열을 만들어 놓고 그에 맞는 값을 찾아 출력하면 된다.
# 이렇게 수행하면 시간복잡도는 O(N log N) 이 된다.
#
# 는 개뿔 시간초과 계속 되서 pypy3으로 해결했다.

import sys

# 갯수 T, 각각 N 입력 받기
t = int(sys.stdin.readline().rstrip())
n = list(int(sys.stdin.readline().rstrip()) for _ in range(t))
max_n = max(n)

# 약수 합의 리스트 S
s = [0] * (max_n + 1)
dp = [0] * (max_n + 1)

# 최대값 위치까지의 모든 약수들의 합 f(N)을 구해둔다.
for i in range(1, max_n + 1):

    j = 1  # 곱해줄 수
    while True:
        # i * j : 약수로 i를 값는 수
        s[i * j] += i  # 그 위치에 약수를 더해준다.
        j += 1

        if i * j >= len(s):  # 만약 최대 값의 위치를 벗어난다면
            break  # 반복문 탈출, 다음 수로

# 그 약수들을 누적해서 더한 값 g(N) 리스트를 구해준다.
for i in range(1, max_n + 1):
    dp[i] = dp[i - 1] + s[i]

for i in n:
    sys.stdout.write('{0}\n'.format(dp[i]))

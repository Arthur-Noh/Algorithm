# 코딩 테스트 준비 - 기초
# 백준 10844 쉬운 계단 수
# 등급 실버 1

# 문제 해결 아이디어
# 각 자리수에서 맨 뒤에 올 수 있는 숫자의 갯수(0 ~ 9)
#           0   1   2   3   4   5   6   7   8   9
# 자리수(1)  0   1   1   1   1   1   1   1   1   1
# 자리수(2)  1   1   2   2   2   2   2   2   2   1
# 자리수(3)  1   3   3   4   4   4   4   4   3   2

# 규칙을 살펴보면, 자리수가 1일 때, 각 숫자들이 맨 뒷자리에 올 수 있는 개수는 1씩이다.
# 왜냐하면 자리수가 하나밖에 없기 때문이다.

# 자리수가 2일 때를 보자.
# 맨 뒤에 0이 올 수 있는 경우의 수 - 10이 있다. (1개)
# 맨 뒤에 1이 올 수 있는 경우의 수 - 21이 있다. (1개)
# 맨 뒤에 2가 올 수 있는 경우의 수 - 12, 32가 있다. (2개)

# 이렇게 3자리수 까지 구해보면 위와 같은 표가 나올 수 있다.
# 규칙을 찾아보면, 해당 위치의 대각선 위 위치의 숫자들의 합인 것을 알 수 있다.
# 0은 왼쪽 대각선이 없으므로 오른쪽 대각선만, 9도 마찬가지로 오른쪽 대각선은 없으므로 왼쪽 대각선만 계산한다.

# 이렇게 점화식을 세워 코드를 작성한다.
# i = 자리수
# j = 맨 뒤에 갈 수 있는 경우의 수(0 ~ 9)
# j = 0     dp[i][j] = dp[i - 1][1]
# j = 9     dp[i][j] = dp[i - 1][8]
# j = 1 ~ 8 dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]

import sys
n = int(sys.stdin.readline().rstrip())
dp = [[0 for i in range(10)] for j in range(101)]

for i in range(1, 10):
    dp[1][i] = 1

for i in range(2, n + 1):
    for j in range(10):
        if j == 0:
            dp[i][j] = dp[i - 1][1]

        elif j == 9:
            dp[i][j] = dp[i - 1][8]

        else:
            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]

print(sum(dp[n]) % 1000000000)

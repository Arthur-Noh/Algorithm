# 코딩 테스트 준비 - 기초
# 백준 2225 합분해
# 등급 골드 5

# 문제 해결 아이디어
# N과 K의 관계를 생각해보면 된다.
# K에 상관없이 N이 1인 경우 합이 N이 되는 경우의 수는 K 개이다.
# ex) K = 2 이고, N = 1 인 경우 (0, 1), (1, 0) - 2개
# ex) K = 4 이고, N = 1 인 경우 (0, 0, 0, 1), (0, 0, 1, 0), (0, 1, 0, 0), (1, 0, 0, 0) - 4개

# K = 1인 경우, N에 상관없이 합이 N이 되는 경우의 수는 1개이다.(N 자신 1개)

# K = 2 이면
# 예제와 같이 N = 20이면, K = 21 이다.
# (10, 10) 1개와
# (0, 20), (1, 19), (2, 18), (3, 17), (4, 16), (5, 15), (6, 14), (7, 13), (8, 12), (9, 11) 10개의 순서를 바꾼 경우 20가지
# 20 + 1 = 21

# N = 3이면
# (3, 0), (1, 2) 2가지를 순서를 뒤바꾼 경우 총 4가지이다.
# 이를 통해 K = 2 이면 합이 N이 되는 경우의 수는 N + 1개 이다.

# K = 3이면
# N = 2일 때, (0, 1, 1), (1, 1, 0), (1, 0, 1), (0, 0, 2), (0, 2, 0), (2, 0, 0) 6개 이다.
# N = 3일 때, (0, 0, 3), (0, 3, 0), (3, 0, 0), (0, 1, 2), (0, 2, 1), (1, 2, 0), (2, 1, 0), (1, 0, 2), (2, 0, 1), (1, 1, 1) 10개 이다.

# 이를 표로 표현하면 다음과 같다.
#       N = 1   N = 2   N = 3   N = 4   N = 5 ...
# K = 1   1       1       1       1       1
# K = 2   2       3       4       5       6
# K = 3   3       6       10      15      21
# 이를 점화식으로 나타내면
# dp[i][j] = dp[i][j - 1] + dp[i - 1][j] (i, j가 2 이상인 경우)를 도출 할 수 있다.

import sys
n, k = int(sys.stdin.readline().split())
dp = [[0] * 201 for i in range(201)]

for i in range(201):
    dp[1][i] = 1
    dp[2][i] = i + 1

for i in range(2, 201):
    dp[i][1] = i

    for j in range(2, 201):
        dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % 1000000000
        
print(dp[k][n])

# 그리디 알고리즘
# 백준 1744번
# 등급 골드 4

# 문제 해결 아이디어
# 수를 적절하게 묶었을 때, 그 합이 최대가 되게하는 프로그램을 작성하기
# 내림차순 배열을 진행하여 큰 수를 각각 곱한다.
# 입력받은 값을 양수, 음수냐로 구분한다.
# 양수의 경우 내림차순, 음수의 경우 오름차순으로 정렬하여 각각 곱 연산을 수행한다.

# 양수의 경우
# 양수의 갯수가 짝수일 때는 서로 짝을 맞춰 곱해주면 된다.
# 양수의 갯수가 홀수일 때는 서로 짝을 맞춰 곱해준 후 마지막 값을 더하면 된다.

# 음수의 경우
# 음수의 갯수가 짝수일 때는 서로 짝을 맞춰 곱해주면 된다.
# 음수의 갯수가 홀수일 때는 서로 짝을 맞춰 곱해준 후 마지막 값을 빼주면 된다.(기본이 - 이므로)
# 음수에는 0을 포함시켜서 음수 * 0을 해 0을 더하게 계산하면 최대값을 구할 수 있다.
# 그냥 단순하게 음수에 0을 포함시키면 된다.

# 만약 1이 존재할 때
# 만약 양수가 짝수개 일때 1이라는 값이 존재하면
# X * 1 < X + 1 이 항상 값이 더 크므로
# 1은 나올때마다 항상 더해주는 것이 중요하다.

import sys
n = int(sys.stdin.readline())
l = list(int(sys.stdin.readline()) for _ in range(n))

p = [] # 양수를 저장하는 리스트
m = [] # 음수를 저장하는 리스트
s = 0  # 합계

for i in l:
    if i > 1: # 1보다 큰 양수의 경우 p
        p.append(i)
    elif i == 1: # 1인 경우 바로 더해준다.
        s += i
    else: # 0 이하의 음수는 m
        m.append(i)

p.sort(reverse=True) # 양수는 내림차순 정렬
m.sort() # 음수는 오름차순 정렬을 수행한다.

if len(p) % 2 == 0:
    for i in range(0, len(p), 2):
        s += p[i] * p[i+1]
else:
    for i in range(0, len(p)-1, 2): # 홀수의 경우
        s += p[i] * p[i+1]
    s += p[len(p)-1] # 짝수개 처럼 반복 수행한 후, 마지막에 남는 수를 더해주면 된다.

if len(m) % 2 == 0:
    for i in range(0, len(m), 2):
        s += m[i] * m[i+1]
else:
    for i in range(0, len(m)-1, 2):
        s += m[i] * m[i+1]
    s += m[len(m)-1]

print(s)
